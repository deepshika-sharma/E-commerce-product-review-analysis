import pandas as pdfrom nltk.stem import PorterStemmerfrom sklearn.feature_extraction.text import TfidfVectorizerimport spacyimport osfrom langdetect import detectimport math# import jellyfishimport pickleimport urllib.requestfrom nltk.metrics import edit_distancefrom textblob import TextBlob, Word# from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzerimport warningswarnings.filterwarnings("ignore", category=FutureWarning)nlp = spacy.load("en_core_web_sm")stemmer = PorterStemmer()class review_feature:    def __init__(self):        pass    def lang_detect(self, text):        return detect(text)        def gibberish_detection(self,l, prefix_path = './'):        '''        Input: String        prefix_path: path of gibberish pickle weights        Output: True or False        '''        if self.model_data == None:            self.model_data = pickle.load(open(os.path.abspath(prefix_path)+'/gib_model.pki', 'rb'))        accepted_chars = 'abcdefghijklmnopqrstuvwxyz '        pos = dict([(char, idx) for idx, char in enumerate(accepted_chars)])        def normalize(line):            """ Return only the subset of chars from accepted_chars.            This helps keep the  model relatively small by ignoring punctuation,            infrequenty symbols, etc. """            return [c.lower() for c in line if c.lower() in accepted_chars]        def ngram(n, l):            """ Return all n grams from l after normalizing """            filtered = normalize(l)            for start in range(0, len(filtered) - n + 1):                yield ''.join(filtered[start:start + n])        def avg_transition_prob(l, log_prob_mat):            """ Return the average transition prob from l through log_prob_mat. """            log_prob = 0.0            transition_ct = 0            for a, b in ngram(2, l):                log_prob += log_prob_mat[pos[a]][pos[b]]                transition_ct += 1            # The exponentiation translates from log probs to probs.            return math.exp(log_prob / (transition_ct or 1))        model_mat = self.model_data['mat']        threshold = self.model_data['thresh']        return (avg_transition_prob(l, model_mat) < threshold)